[
  {
    "name": "active-traders.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'mostActive' function below.\n *\n * The function is expected to return a STRING_ARRAY.\n * The function accepts STRING_ARRAY customers as parameter.\n */\n\n/*\n * Algorithm:\n * 1. Count the number of transactions for each unique customer:\n *    a. Iterate through all customer transactions\n *    b. For each customer, check if we've seen them before\n *    c. If not, add them to our unique customers list\n *    d. If yes, increment their transaction count\n * 2. Filter customers with at least 5% of the total transactions:\n *    a. Calculate the threshold: 5% of total transactions\n *    b. Include only customers whose transaction count exceeds this threshold\n * 3. Sort the filtered list of active traders alphabetically\n * 4. Return the sorted list of active traders\n *\n * Time Complexity:\n * - O(n\u00b2) for counting unique customers in the worst case\n * - O(m log m) for sorting the active traders list\n * Where n is the total number of transactions, m is the number of unique customers\n *\n * Space Complexity: O(m) where m is the number of unique customers\n */\n\n// Structure to store customer information\ntypedef struct\n{\n    char *name;\n    int count;\n} CustomerInfo;\n\n// Comparison function for qsort (for alphabetical sorting)\nint compareCustomers(const void *a, const void *b)\n{\n    return strcmp(((CustomerInfo *)a)->name, ((CustomerInfo *)b)->name);\n}\n\nchar **mostActive(int customers_count, char **customers, int *result_count)\n{\n    const int MAX_CUSTOMERS = 10000; // Maximum number of unique customers\n    CustomerInfo *unique_customers = (CustomerInfo *)malloc(MAX_CUSTOMERS * sizeof(CustomerInfo));\n    int unique_count = 0;\n\n    // Count occurrences of each customer\n    for (int i = 0; i < customers_count; i++)\n    {\n        // Check if customer already exists in our array\n        int found = 0;\n        for (int j = 0; j < unique_count; j++)\n        {\n            if (strcmp(unique_customers[j].name, customers[i]) == 0)\n            {\n                unique_customers[j].count++;\n                found = 1;\n                break;\n            }\n        }\n\n        // If not found, add as a new customer\n        if (!found)\n        {\n            unique_customers[unique_count].name = strdup(customers[i]);\n            unique_customers[unique_count].count = 1;\n            unique_count++;\n        }\n    }\n\n    // Create result array\n    char **result = (char **)malloc(unique_count * sizeof(char *));\n    *result_count = 0;\n\n    // Filter customers with >= 5% of transactions\n    float threshold = 0.05 * customers_count;\n    for (int i = 0; i < unique_count; i++)\n    {\n        if (unique_customers[i].count >= threshold)\n        {\n            result[*result_count] = strdup(unique_customers[i].name);\n            (*result_count)++;\n        }\n    }\n\n    // Create a new array with just the active traders for sorting\n    CustomerInfo *active_traders = (CustomerInfo *)malloc(*result_count * sizeof(CustomerInfo));\n    for (int i = 0; i < *result_count; i++)\n    {\n        active_traders[i].name = result[i];\n    }\n\n    // Sort active traders alphabetically\n    qsort(active_traders, *result_count, sizeof(CustomerInfo), compareCustomers);\n\n    // Update result array with sorted names\n    for (int i = 0; i < *result_count; i++)\n    {\n        result[i] = active_traders[i].name;\n    }\n\n    // Free memory\n    for (int i = 0; i < unique_count; i++)\n    {\n        free(unique_customers[i].name);\n    }\n    free(unique_customers);\n    free(active_traders);\n\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int customers_count;\n    scanf(\"%d\", &customers_count);\n\n    char **customers = malloc(customers_count * sizeof(char *));\n    for (int i = 0; i < customers_count; i++)\n    {\n        customers[i] = malloc(101 * sizeof(char)); // Assuming max length of 100\n        scanf(\"%s\", customers[i]);\n    }\n\n    int result_count;\n    char **result = mostActive(customers_count, customers, &result_count);\n\n    for (int i = 0; i < result_count; i++)\n    {\n        fprintf(fptr, \"%s\\n\", result[i]);\n        free(result[i]);\n    }\n    fprintf(fptr, \"\\n\");\n\n    for (int i = 0; i < customers_count; i++)\n    {\n        free(customers[i]);\n    }\n    free(customers);\n    free(result);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "balanced-system-files-partition.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n/*\n * Complete the 'mostBalancedPartition' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY parent\n *  2. INTEGER_ARRAY files_size\n */\n\n/*\n * Algorithm:\n * 1. Calculate the total size of each subtree in the file system tree:\n *    a. Use a recursive approach to sum up file sizes\n *    b. For each node, its total size = its own size + sizes of all child subtrees\n * 2. Find the optimal partition point by:\n *    a. The system is divided into two parts by removing one edge from the tree\n *    b. When edge to node i is cut, we get subtree i and the rest of the tree\n *    c. Size of subtree i is size_sums[i]\n *    d. Size of the rest of the tree is total_size - size_sums[i]\n * 3. Calculate the absolute difference between these two parts for each possible cut\n * 4. Return the minimum difference found\n *\n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(n) for storing the size sums\n */\n\n// Recursive function to calculate size sums\nlong size_sums_rec(int node, int *parent, int *files_size, long *size_sums, int parent_count)\n{\n    // Calculate children first\n    for (int i = 0; i < parent_count; i++)\n    {\n        if (parent[i] == node)\n        {\n            size_sums[i] = size_sums_rec(i, parent, files_size, size_sums, parent_count);\n        }\n    }\n\n    // Sum up this node's size plus all its children's sizes\n    long sum = files_size[node];\n    for (int i = 0; i < parent_count; i++)\n    {\n        if (parent[i] == node)\n        {\n            sum += size_sums[i];\n        }\n    }\n\n    size_sums[node] = sum;\n    return sum;\n}\n\nint mostBalancedPartition(int parent_count, int *parent, int files_size_count, int *files_size)\n{\n    // Allocate and initialize size_sums array\n    long *size_sums = (long *)malloc(parent_count * sizeof(long));\n    for (int i = 0; i < parent_count; i++)\n    {\n        size_sums[i] = -1; // Initialize with -1 to indicate not calculated yet\n    }\n\n    // Calculate size sums using recursion\n    size_sums_rec(0, parent, files_size, size_sums, parent_count);\n\n    // Find the minimum absolute difference\n    long total_size = size_sums[0];\n    long min_diff = LONG_MAX;\n\n    for (int i = 1; i < parent_count; i++)\n    {\n        long diff = labs(total_size - 2 * size_sums[i]);\n        if (diff < min_diff)\n        {\n            min_diff = diff;\n        }\n    }\n\n    free(size_sums);\n    return (int)min_diff;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int parent_count;\n    scanf(\"%d\", &parent_count);\n\n    int *parent = malloc(parent_count * sizeof(int));\n    for (int i = 0; i < parent_count; i++)\n    {\n        scanf(\"%d\", &parent[i]);\n    }\n\n    int files_size_count;\n    scanf(\"%d\", &files_size_count);\n\n    int *files_size = malloc(files_size_count * sizeof(int));\n    for (int i = 0; i < files_size_count; i++)\n    {\n        scanf(\"%d\", &files_size[i]);\n    }\n\n    int result = mostBalancedPartition(parent_count, parent, files_size_count, files_size);\n\n    fprintf(fptr, \"%d\\n\", result);\n\n    free(parent);\n    free(files_size);\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "longest-subarray.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * Complete the 'longestSubarray' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts INTEGER_ARRAY arr as parameter.\n */\n\n/*\n * Algorithm:\n * 1. For each possible starting position:\n *    a. Try to form a subarray with at most 2 distinct values\n *    b. Additionally, the two values must differ by at most 1\n * 2. Use a window expansion approach:\n *    a. Track distinct values seen so far (at most 2)\n *    b. When a new value is encountered, check if it can be added:\n *       i. If we have 0 values so far, add it\n *       ii. If we have 1 value so far, add it if |new_val - existing_val| \u2264 1\n *       iii. If we have 2 values already, check if the new value matches either\n *    c. If a value can't be added, the window can't be expanded further\n * 3. Track the maximum valid window length\n *\n * Time Complexity: O(n\u00b2) where n is the array length\n * Space Complexity: O(1) additional space\n */\n\nint longestSubarray(int arr_count, int *arr)\n{\n    int ans = 0;\n\n    // O(n^2) is okay because of constraints.\n    for (int i = 0; i < arr_count; i++)\n    {\n        int w[2] = {-1, -1}; // Stores the two distinct values (-1 means empty)\n        int w_count = 0;     // Number of distinct values stored\n        int cnt = 0;         // Length of current subarray\n\n        for (int j = i; j < arr_count; j++)\n        {\n            // Check if current element matches either of the two values\n            if (w_count > 0 && arr[j] == w[0])\n            {\n                cnt++;\n                continue;\n            }\n\n            if (w_count > 1 && arr[j] == w[1])\n            {\n                cnt++;\n                continue;\n            }\n\n            // If we don't have any value yet, add this as first\n            if (w_count == 0)\n            {\n                w[0] = arr[j];\n                w_count = 1;\n                cnt++;\n            }\n            // If we have only one value, check if new value can be added\n            else if (w_count == 1)\n            {\n                if (abs(w[0] - arr[j]) <= 1)\n                {\n                    w[1] = arr[j];\n                    w_count = 2;\n                    cnt++;\n                }\n                else\n                {\n                    // If difference > 1, we can't add this element\n                    break;\n                }\n            }\n            // If we already have two values, and this is a third distinct value, break\n            else\n            {\n                break;\n            }\n        }\n\n        // Update answer with max subarray length found\n        if (cnt > ans)\n        {\n            ans = cnt;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int arr_count;\n    scanf(\"%d\", &arr_count);\n\n    int *arr = malloc(arr_count * sizeof(int));\n    for (int i = 0; i < arr_count; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int result = longestSubarray(arr_count, arr);\n\n    fprintf(fptr, \"%d\\n\", result);\n\n    free(arr);\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "maximum-cost-of-laptop-count.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'maxCost' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY cost\n *  2. STRING_ARRAY labels\n *  3. INTEGER dailyCount\n */\n\n/*\n * Algorithm:\n * 1. Process laptops in order, tracking both cost and the count of legal laptops\n * 2. For each laptop:\n *    a. Add its cost to the current batch's cost accumulator\n *    b. If the laptop is 'legal', increment the legal count\n * 3. When we reach exactly 'dailyCount' legal laptops:\n *    a. Compare the current batch's total cost with the maximum seen so far\n *    b. Update the maximum cost if current batch is more expensive\n *    c. Reset the counters to start a new batch\n * 4. Return the maximum cost found\n *\n * Time Complexity: O(n) where n is the number of laptops\n * Space Complexity: O(1) additional space (not counting input/output)\n */\n\nint maxCost(int cost_count, int *cost, char **labels, int dailyCount)\n{\n    int ans = 0;\n    int cur_cnt = 0;\n    int cur_cost = 0;\n\n    for (int i = 0; i < cost_count; i++)\n    {\n        cur_cost += cost[i];\n\n        // Skip illegal labels\n        if (strcmp(labels[i], \"illegal\") == 0)\n        {\n            continue;\n        }\n\n        cur_cnt++;\n\n        // Check if we've reached the daily count\n        if (cur_cnt == dailyCount)\n        {\n            // Update answer if current cost is greater\n            if (cur_cost > ans)\n            {\n                ans = cur_cost;\n            }\n\n            // Reset counters for the next batch\n            cur_cnt = 0;\n            cur_cost = 0;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int cost_count;\n    scanf(\"%d\", &cost_count);\n\n    int *cost = malloc(cost_count * sizeof(int));\n    for (int i = 0; i < cost_count; i++)\n    {\n        scanf(\"%d\", &cost[i]);\n    }\n\n    int labels_count;\n    scanf(\"%d\", &labels_count);\n\n    char **labels = malloc(labels_count * sizeof(char *));\n    for (int i = 0; i < labels_count; i++)\n    {\n        labels[i] = malloc(8 * sizeof(char)); // \"illegal\" or \"legal\" + null terminator\n        scanf(\"%s\", labels[i]);\n    }\n\n    int dailyCount;\n    scanf(\"%d\", &dailyCount);\n\n    int result = maxCost(cost_count, cost, labels, dailyCount);\n\n    fprintf(fptr, \"%d\\n\", result);\n\n    for (int i = 0; i < labels_count; i++)\n    {\n        free(labels[i]);\n    }\n    free(labels);\n    free(cost);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "nearly-similar-rectangles.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'nearlySimilarRectangles' function below.\n *\n * The function is expected to return a LONG_INTEGER.\n * The function accepts 2D_LONG_INTEGER_ARRAY sides as parameter.\n */\n\n/*\n * Algorithm:\n * 1. Two rectangles are \"nearly similar\" if their width-to-height ratios are the same\n * 2. For each rectangle, normalize its ratio by:\n *    a. Finding the GCD (greatest common divisor) of width and height\n *    b. Dividing both width and height by their GCD\n * 3. Use a hash table to group rectangles with the same normalized ratio\n * 4. For each group, calculate the number of pairs using the formula n*(n-1)/2\n *    where n is the number of rectangles in the group\n * 5. Sum up the pairs from all groups\n *\n * Optimization:\n * - Instead of calculating pairs afterward, we count them during insertion\n *   by adding the current count of matching ratios to our result\n *\n * Time Complexity: O(n * log(max(w,h))) where:\n * - n is the number of rectangles\n * - w, h are the maximum width and height values\n * - log term is from GCD calculation\n * Space Complexity: O(n) for the hash table\n */\n\n// Calculate GCD (Greatest Common Divisor)\nlong gcd(long a, long b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Structure for storing normalized ratios\nstruct Ratio\n{\n    long width;\n    long height;\n};\n\n// Hash table entry\nstruct Entry\n{\n    struct Ratio ratio;\n    int count;\n    struct Entry *next;\n};\n\n// Simple hash function\nunsigned long hash(long w, long h)\n{\n    return (w * 31 + h) % 10007; // Prime number\n}\n\nlong nearlySimilarRectangles(int sides_rows, long **sides)\n{\n    const int TABLE_SIZE = 10007; // Prime number for hash table\n    struct Entry **table = (struct Entry **)calloc(TABLE_SIZE, sizeof(struct Entry *));\n\n    long result = 0;\n\n    for (int i = 0; i < sides_rows; i++)\n    {\n        long w = sides[i][0];\n        long h = sides[i][1];\n\n        // Calculate GCD to normalize ratio\n        long g = gcd(w, h);\n        w /= g;\n        h /= g;\n\n        // Hash the normalized ratio\n        unsigned long h_val = hash(w, h);\n\n        // Check if this ratio already exists\n        struct Entry *entry = table[h_val];\n        int found = 0;\n\n        while (entry != NULL)\n        {\n            if (entry->ratio.width == w && entry->ratio.height == h)\n            {\n                // Found matching ratio, add to count and calculate new pairs\n                result += entry->count;\n                entry->count++;\n                found = 1;\n                break;\n            }\n            entry = entry->next;\n        }\n\n        // If not found, add new entry\n        if (!found)\n        {\n            struct Entry *new_entry = (struct Entry *)malloc(sizeof(struct Entry));\n            new_entry->ratio.width = w;\n            new_entry->ratio.height = h;\n            new_entry->count = 1;\n            new_entry->next = table[h_val];\n            table[h_val] = new_entry;\n        }\n    }\n\n    // Clean up the hash table\n    for (int i = 0; i < TABLE_SIZE; i++)\n    {\n        struct Entry *entry = table[i];\n        while (entry != NULL)\n        {\n            struct Entry *temp = entry;\n            entry = entry->next;\n            free(temp);\n        }\n    }\n    free(table);\n\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int sides_rows, sides_columns;\n    scanf(\"%d %d\", &sides_rows, &sides_columns);\n\n    long **sides = (long **)malloc(sides_rows * sizeof(long *));\n    for (int i = 0; i < sides_rows; i++)\n    {\n        sides[i] = (long *)malloc(sides_columns * sizeof(long));\n        for (int j = 0; j < sides_columns; j++)\n        {\n            scanf(\"%ld\", &sides[i][j]);\n        }\n    }\n\n    long result = nearlySimilarRectangles(sides_rows, sides);\n\n    fprintf(fptr, \"%ld\\n\", result);\n\n    for (int i = 0; i < sides_rows; i++)\n    {\n        free(sides[i]);\n    }\n    free(sides);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "parallel-processing.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * Complete the 'minTime' function below.\n *\n * The function is expected to return a LONG_INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY files\n *  2. INTEGER numCores\n *  3. INTEGER limit\n */\n\n/*\n * Algorithm:\n * 1. Separate files into two groups:\n *    a. Files divisible by numCores (can benefit from parallel processing)\n *    b. Files not divisible by numCores (no benefit from parallel processing)\n * 2. Sort divisible files in descending order to prioritize larger files for optimization\n * 3. Apply parallel processing to at most 'limit' files from the divisible group\n *    (divide processing time by numCores for these files)\n * 4. Process the rest of the files with single-core processing\n * 5. Sum up all processing times\n *\n * Intuition:\n * - Parallel processing is most beneficial for larger files that are divisible by numCores\n * - Using parallel processing on non-divisible files gives no advantage\n * - Sort to ensure we use the limited parallel slots for the largest possible files\n *\n * Time Complexity: O(n log n) due to sorting\n * Space Complexity: O(n) for storing the separated arrays\n */\n\n// Comparison function for qsort (descending order)\nint compare_desc(const void *a, const void *b)\n{\n    return (*(int *)b - *(int *)a);\n}\n\nlong minTime(int files_count, int *files, int numCores, int limit)\n{\n    int *divisible = (int *)malloc(files_count * sizeof(int));\n    int *not_divisible = (int *)malloc(files_count * sizeof(int));\n    int div_count = 0, not_div_count = 0;\n\n    // Separate files into divisible and not divisible by numCores\n    for (int i = 0; i < files_count; i++)\n    {\n        if (files[i] % numCores == 0)\n        {\n            divisible[div_count++] = files[i];\n        }\n        else\n        {\n            not_divisible[not_div_count++] = files[i];\n        }\n    }\n\n    // Sort divisible files in descending order\n    qsort(divisible, div_count, sizeof(int), compare_desc);\n\n    // Calculate total time\n    long total_time = 0;\n\n    // Process limited number of files with parallel processing\n    for (int i = 0; i < div_count; i++)\n    {\n        if (i < limit)\n        {\n            total_time += divisible[i] / numCores;\n        }\n        else\n        {\n            total_time += divisible[i];\n        }\n    }\n\n    // Add time for non-divisible files (no benefit from parallel processing)\n    for (int i = 0; i < not_div_count; i++)\n    {\n        total_time += not_divisible[i];\n    }\n\n    free(divisible);\n    free(not_divisible);\n\n    return total_time;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int files_count;\n    scanf(\"%d\", &files_count);\n\n    int *files = (int *)malloc(files_count * sizeof(int));\n    for (int i = 0; i < files_count; i++)\n    {\n        scanf(\"%d\", &files[i]);\n    }\n\n    int numCores, limit;\n    scanf(\"%d\", &numCores);\n    scanf(\"%d\", &limit);\n\n    long result = minTime(files_count, files, numCores, limit);\n\n    fprintf(fptr, \"%ld\\n\", result);\n\n    free(files);\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "password-decryption.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'decryptPassword' function below.\n *\n * The function is expected to return a STRING.\n * The function accepts STRING s as parameter.\n */\n\n/*\n * Algorithm:\n * 1. The password is encrypted with three operations:\n *    a. Digits are placed at the beginning and replaced with '0' in the original position\n *    b. Characters around '*' are swapped\n *    c. '*' is added to mark the swapped positions\n *\n * To decrypt:\n * 1. Identify the digits at the beginning of the encrypted password\n * 2. Replace '0's in the string with those digits in reverse order\n * 3. For each '*', swap the two preceding characters\n * 4. Remove placeholder characters (digits at beginning and '*')\n *\n * Time Complexity: O(n) where n is the length of the encrypted password\n * Space Complexity: O(n) for storing the decrypted password\n */\n\nchar *decryptPassword(char *s)\n{\n    int len = strlen(s);\n    char *result = (char *)malloc((len + 1) * sizeof(char));\n    char *temp = (char *)malloc((len + 1) * sizeof(char));\n\n    strcpy(temp, s);\n\n    int i = 0;\n    // Find where numeric prefix ends\n    while (i < len && temp[i] >= '1' && temp[i] <= '9')\n    {\n        i++;\n    }\n\n    // Replace 0's with corresponding digits\n    int j;\n    int digit_index = i - 1;\n    for (j = i; j < len; j++)\n    {\n        if (temp[j] == '0' && digit_index >= 0)\n        {\n            temp[j] = temp[digit_index];\n            temp[digit_index] = ' '; // Mark as used\n            digit_index--;\n        }\n    }\n\n    // Swap characters around '*'\n    for (j = i; j < len; j++)\n    {\n        if (temp[j] == '*')\n        {\n            char t = temp[j - 1];\n            temp[j - 1] = temp[j - 2];\n            temp[j - 2] = t;\n        }\n    }\n\n    // Build result string by copying non-space and non-* characters\n    int result_index = 0;\n    for (j = i; j < len; j++)\n    {\n        if (temp[j] != ' ' && temp[j] != '*')\n        {\n            result[result_index++] = temp[j];\n        }\n    }\n\n    result[result_index] = '\\0';\n    free(temp);\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    char *s = (char *)malloc(10001 * sizeof(char));\n    scanf(\"%s\", s);\n\n    char *result = decryptPassword(s);\n\n    fprintf(fptr, \"%s\\n\", result);\n\n    free(s);\n    free(result);\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "road-repair.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n/*\n * Complete the 'getMinCost' function below.\n *\n * The function is expected to return a LONG_INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY crew_id\n *  2. INTEGER_ARRAY job_id\n */\n\n/*\n * Algorithm:\n * 1. Sort both crew_id and job_id arrays in ascending order\n * 2. Pair each crew with the job having the same relative position after sorting\n *    (i.e., the crew with the smallest ID with the job with the smallest ID, etc.)\n * 3. For each pair, calculate the absolute difference between crew_id and job_id\n * 4. Sum up all these absolute differences to get the total cost\n *\n * Intuition:\n * - Sorting both arrays minimizes the sum of absolute differences when pairing\n *   elements at matching positions\n * - This is optimal because any other pairing would lead to greater differences\n *\n * Time Complexity: O(n log n) due to sorting\n * Space Complexity: O(1) additional space (not counting input/output)\n */\n\n// Compare function for qsort\nint compare(const void *a, const void *b)\n{\n    return (*(int *)a - *(int *)b);\n}\n\nlong getMinCost(int crew_id_count, int *crew_id, int job_id_count, int *job_id)\n{\n    // Sort both arrays\n    qsort(crew_id, crew_id_count, sizeof(int), compare);\n    qsort(job_id, job_id_count, sizeof(int), compare);\n\n    // Calculate sum of absolute differences\n    long total_cost = 0;\n    for (int i = 0; i < crew_id_count; i++)\n    {\n        total_cost += labs((long)crew_id[i] - (long)job_id[i]);\n    }\n\n    return total_cost;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int crew_id_count;\n    scanf(\"%d\", &crew_id_count);\n\n    int *crew_id = malloc(crew_id_count * sizeof(int));\n\n    for (int i = 0; i < crew_id_count; i++)\n    {\n        scanf(\"%d\", &crew_id[i]);\n    }\n\n    int job_id_count;\n    scanf(\"%d\", &job_id_count);\n\n    int *job_id = malloc(job_id_count * sizeof(int));\n\n    for (int i = 0; i < job_id_count; i++)\n    {\n        scanf(\"%d\", &job_id[i]);\n    }\n\n    long result = getMinCost(crew_id_count, crew_id, job_id_count, job_id);\n\n    fprintf(fptr, \"%ld\\n\", result);\n\n    fclose(fptr);\n    free(crew_id);\n    free(job_id);\n\n    return 0;\n}"
  },
  {
    "name": "string-anagram.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'stringAnagram' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts following parameters:\n *  1. STRING_ARRAY dictionary\n *  2. STRING_ARRAY query\n */\n\n/*\n * Algorithm:\n * 1. Create a hash table to store sorted words from the dictionary:\n *    a. For each word in the dictionary, sort its characters\n *    b. Use the sorted word as a key, and count how many words map to the same sorted form\n * 2. For each query word:\n *    a. Sort the query word\n *    b. Look up the sorted word in the hash table\n *    c. Return the count of matching words (or 0 if none found)\n *\n * Note: A hash table is used for efficient lookups. Two words are anagrams if they have the same sorted order.\n *\n * Time Complexity: O(n*m log m + q*k log k) where:\n * - n is the number of dictionary words\n * - m is the maximum length of a dictionary word\n * - q is the number of query words\n * - k is the maximum length of a query word\n * Space Complexity: O(n) for storing the hash table\n */\n\n// Function to sort a string\nvoid sortString(char *str)\n{\n    int n = strlen(str);\n    char temp;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            if (str[i] > str[j])\n            {\n                temp = str[i];\n                str[i] = str[j];\n                str[j] = temp;\n            }\n        }\n    }\n}\n\n// Structure for dictionary entries\nstruct DictEntry\n{\n    char *sorted_word;\n    int count;\n};\n\n// Simple hash function for strings\nunsigned long hash(char *str)\n{\n    unsigned long hash = 5381;\n    int c;\n\n    while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n\n    return hash;\n}\n\nint *stringAnagram(int dictionary_count, char **dictionary, int query_count, char **query)\n{\n    // Create a structure to store dictionary entries\n    const int TABLE_SIZE = 10007; // Prime number for hash table\n    struct DictEntry **table = (struct DictEntry **)calloc(TABLE_SIZE, sizeof(struct DictEntry *));\n\n    // Process dictionary words\n    for (int i = 0; i < dictionary_count; i++)\n    {\n        // Create a copy to sort\n        int len = strlen(dictionary[i]);\n        char *sorted = (char *)malloc((len + 1) * sizeof(char));\n        strcpy(sorted, dictionary[i]);\n        sortString(sorted);\n\n        // Hash the sorted word\n        unsigned long h = hash(sorted) % TABLE_SIZE;\n\n        // Find if this sorted word already exists in our table\n        int found = 0;\n        struct DictEntry *entry = table[h];\n        while (entry != NULL)\n        {\n            if (strcmp(entry->sorted_word, sorted) == 0)\n            {\n                entry->count++;\n                found = 1;\n                break;\n            }\n            entry = entry->count > 0 ? (struct DictEntry *)entry->sorted_word : NULL; // Use count field as next pointer\n        }\n\n        // If not found, add new entry\n        if (!found)\n        {\n            struct DictEntry *new_entry = (struct DictEntry *)malloc(sizeof(struct DictEntry));\n            new_entry->sorted_word = sorted;\n            new_entry->count = 1;\n            // Insert at the head of the chain\n            if (table[h] != NULL)\n            {\n                entry = (struct DictEntry *)table[h]->sorted_word;\n                table[h]->sorted_word = (char *)new_entry;\n            }\n            else\n            {\n                table[h] = new_entry;\n            }\n        }\n        else\n        {\n            free(sorted); // We don't need this copy\n        }\n    }\n\n    // Process queries\n    int *result = (int *)calloc(query_count, sizeof(int));\n\n    for (int i = 0; i < query_count; i++)\n    {\n        // Sort the query word\n        int len = strlen(query[i]);\n        char *sorted = (char *)malloc((len + 1) * sizeof(char));\n        strcpy(sorted, query[i]);\n        sortString(sorted);\n\n        // Look up in the hash table\n        unsigned long h = hash(sorted) % TABLE_SIZE;\n        struct DictEntry *entry = table[h];\n\n        while (entry != NULL)\n        {\n            if (strcmp(entry->sorted_word, sorted) == 0)\n            {\n                result[i] = entry->count;\n                break;\n            }\n            entry = entry->count > 0 ? (struct DictEntry *)entry->sorted_word : NULL;\n        }\n\n        free(sorted);\n    }\n\n    // Clean up the hash table\n    for (int i = 0; i < TABLE_SIZE; i++)\n    {\n        struct DictEntry *entry = table[i];\n        while (entry != NULL)\n        {\n            struct DictEntry *next = entry->count > 0 ? (struct DictEntry *)entry->sorted_word : NULL;\n            free(entry->sorted_word);\n            free(entry);\n            entry = next;\n        }\n    }\n    free(table);\n\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int dictionary_count;\n    scanf(\"%d\", &dictionary_count);\n\n    char **dictionary = (char **)malloc(dictionary_count * sizeof(char *));\n    for (int i = 0; i < dictionary_count; i++)\n    {\n        dictionary[i] = (char *)malloc(1001 * sizeof(char));\n        scanf(\"%s\", dictionary[i]);\n    }\n\n    int query_count;\n    scanf(\"%d\", &query_count);\n\n    char **query = (char **)malloc(query_count * sizeof(char *));\n    for (int i = 0; i < query_count; i++)\n    {\n        query[i] = (char *)malloc(1001 * sizeof(char));\n        scanf(\"%s\", query[i]);\n    }\n\n    int *result = stringAnagram(dictionary_count, dictionary, query_count, query);\n\n    for (int i = 0; i < query_count; i++)\n    {\n        fprintf(fptr, \"%d\\n\", result[i]);\n        free(query[i]);\n        free(dictionary[i]);\n    }\n    fprintf(fptr, \"\\n\");\n\n    free(dictionary);\n    free(query);\n    free(result);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "subarray-sums.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * Complete the 'findSum' function below.\n *\n * The function is expected to return a LONG_INTEGER_ARRAY.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY numbers\n *  2. 2D_INTEGER_ARRAY queries\n */\n\n/*\n * Algorithm:\n * 1. Use prefix sum technique to efficiently calculate subarray sums\n * 2. Create two prefix arrays:\n *    a. prefix_sum: For computing regular subarray sums\n *    b. zero_count: For tracking the number of zeros in a prefix\n * 3. For each query (l, r, x):\n *    a. Calculate regular sum using prefix_sum: prefix_sum[r] - prefix_sum[l-1]\n *    b. Find zeros in range using zero_count: zero_count[r] - zero_count[l-1]\n *    c. Add x * (zeros in range) to the sum\n * 4. Return results for all queries\n *\n * Time Complexity: O(n + q) where n is the array length and q is number of queries\n * Space Complexity: O(n) for prefix sum arrays\n */\n\nlong *findSum(int numbers_count, int *numbers, int queries_rows, int **queries)\n{\n    long *prefix_sum = (long *)malloc((numbers_count + 1) * sizeof(long));\n    int *zero_count = (int *)malloc((numbers_count + 1) * sizeof(int));\n    long *result = (long *)malloc(queries_rows * sizeof(long));\n\n    prefix_sum[0] = 0;\n    zero_count[0] = 0;\n\n    // Precompute prefix sum and zero count\n    for (int i = 0; i < numbers_count; i++)\n    {\n        prefix_sum[i + 1] = prefix_sum[i] + numbers[i];\n        zero_count[i + 1] = zero_count[i] + (numbers[i] == 0);\n    }\n\n    // Process each query\n    for (int i = 0; i < queries_rows; i++)\n    {\n        int l = queries[i][0];\n        int r = queries[i][1];\n        int x = queries[i][2];\n\n        // Calculate sum and add x * count of zeros\n        result[i] = (prefix_sum[r] - prefix_sum[l - 1]) + (x * (zero_count[r] - zero_count[l - 1]));\n    }\n\n    free(prefix_sum);\n    free(zero_count);\n\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int numbers_count;\n    scanf(\"%d\", &numbers_count);\n\n    int *numbers = (int *)malloc(numbers_count * sizeof(int));\n    for (int i = 0; i < numbers_count; i++)\n    {\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    int queries_rows;\n    int queries_columns;\n    scanf(\"%d %d\", &queries_rows, &queries_columns);\n\n    int **queries = (int **)malloc(queries_rows * sizeof(int *));\n    for (int i = 0; i < queries_rows; i++)\n    {\n        queries[i] = (int *)malloc(queries_columns * sizeof(int));\n        for (int j = 0; j < queries_columns; j++)\n        {\n            scanf(\"%d\", &queries[i][j]);\n        }\n    }\n\n    long *result = findSum(numbers_count, numbers, queries_rows, queries);\n\n    for (int i = 0; i < queries_rows; i++)\n    {\n        fprintf(fptr, \"%ld\\n\", result[i]);\n        free(queries[i]);\n    }\n    fprintf(fptr, \"\\n\");\n\n    free(numbers);\n    free(queries);\n    free(result);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "unexpected-demand.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * Complete the 'filledOrders' function below.\n *\n * The function is expected to return an INTEGER.\n * The function accepts following parameters:\n *  1. INTEGER_ARRAY order\n *  2. INTEGER k\n */\n\n/*\n * Algorithm:\n * 1. Sort the orders by size (smallest first)\n * 2. Process orders in ascending order:\n *    a. If we have enough capacity (k) to fulfill an order, fulfill it\n *    b. Decrement the remaining capacity by the order size\n *    c. If we don't have enough capacity, break\n * 3. Return the number of orders fulfilled\n *\n * Time Complexity: O(n log n) due to sorting\n * Space Complexity: O(1) extra space (not counting input)\n */\n\n// Comparison function for qsort\nint compare(const void *a, const void *b)\n{\n    return (*(int *)a - *(int *)b);\n}\n\nint filledOrders(int order_count, int *order, int k)\n{\n    // Sort the order array\n    qsort(order, order_count, sizeof(int), compare);\n\n    int ans = 0;\n    for (int i = 0; i < order_count; i++)\n    {\n        if (order[i] <= k)\n        {\n            ans++;\n            k -= order[i];\n        }\n        else\n        {\n            break;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int order_count;\n    scanf(\"%d\", &order_count);\n\n    int *order = malloc(order_count * sizeof(int));\n\n    for (int i = 0; i < order_count; i++)\n    {\n        scanf(\"%d\", &order[i]);\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int result = filledOrders(order_count, order, k);\n\n    fprintf(fptr, \"%d\\n\", result);\n\n    fclose(fptr);\n    free(order);\n\n    return 0;\n}"
  },
  {
    "name": "usernames-changes.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'possibleChanges' function below.\n *\n * The function is expected to return a STRING_ARRAY.\n * The function accepts STRING_ARRAY usernames as parameter.\n */\n\n/*\n * Algorithm:\n * 1. For each username, check if we can create a lexicographically smaller name\n * 2. A username can be made lexicographically smaller if there exists two characters\n *    where a character at index i is greater than a character at index j, where i < j\n * 3. If such a pair exists, swap them to get a smaller username (though we don't actually do the swap)\n * 4. For each username, return \"YES\" if such a swap is possible, \"NO\" otherwise\n *\n * Time Complexity: O(n * m^2) where n is the number of usernames and m is the max length of a username\n * Space Complexity: O(n) for storing the results\n */\n\nchar **possibleChanges(int usernames_count, char **usernames)\n{\n    char **ans = (char **)malloc(usernames_count * sizeof(char *));\n\n    for (int i = 0; i < usernames_count; i++)\n    {\n        ans[i] = (char *)malloc(4 * sizeof(char)); // \"YES\" or \"NO\" plus null terminator\n\n        if (strlen(usernames[i]) <= 1)\n        {\n            strcpy(ans[i], \"NO\");\n            continue;\n        }\n\n        int found = 0;\n        for (int j = 0; j < strlen(usernames[i]) - 1; j++)\n        {\n            if (usernames[i][j] > usernames[i][j + 1])\n            {\n                strcpy(ans[i], \"YES\");\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found)\n        {\n            strcpy(ans[i], \"NO\");\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int usernames_count;\n    scanf(\"%d\", &usernames_count);\n\n    char **usernames = (char **)malloc(usernames_count * sizeof(char *));\n\n    for (int i = 0; i < usernames_count; i++)\n    {\n        usernames[i] = (char *)malloc(1001 * sizeof(char));\n        scanf(\"%s\", usernames[i]);\n    }\n\n    char **result = possibleChanges(usernames_count, usernames);\n\n    for (int i = 0; i < usernames_count; i++)\n    {\n        fprintf(fptr, \"%s\\n\", result[i]);\n        free(result[i]);\n        free(usernames[i]);\n    }\n\n    free(result);\n    free(usernames);\n\n    fclose(fptr);\n\n    return 0;\n}"
  },
  {
    "name": "vowel-substring.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Complete the 'findSubstring' function below.\n *\n * The function is expected to return a STRING.\n * The function accepts following parameters:\n *  1. STRING s\n *  2. INTEGER k\n */\n\n/*\n * Algorithm:\n * 1. Define a sliding window of size k and count vowels in this window\n * 2. Initialize first window by counting vowels in first k characters\n * 3. Slide the window through the string:\n *    a. Add new character (rightmost in window)\n *    b. Remove old character (leftmost in previous window)\n *    c. Check if current window has more vowels than the best found so far\n * 4. Return the substring with maximum vowels, or \"Not found!\" if no vowels exist\n *\n * Time Complexity: O(n) where n is the length of string s\n * Space Complexity: O(k) for storing the result substring\n */\n\nchar *findSubstring(char *s, int k)\n{\n    char vowels[] = \"aeiou\";\n    int len = strlen(s);\n    int best = 0, ans = 0;\n    int i, j;\n\n    // Initialize the first window\n    int cur = 0;\n    for (i = 0; i < k && i < len; i++)\n    {\n        for (j = 0; j < 5; j++)\n        {\n            if (s[i] == vowels[j])\n            {\n                cur++;\n                break;\n            }\n        }\n    }\n\n    best = cur;\n\n    // Slide the window\n    for (i = k; i < len; i++)\n    {\n        // Add new character\n        for (j = 0; j < 5; j++)\n        {\n            if (s[i] == vowels[j])\n            {\n                cur++;\n                break;\n            }\n        }\n\n        // Remove old character\n        for (j = 0; j < 5; j++)\n        {\n            if (s[i - k] == vowels[j])\n            {\n                cur--;\n                break;\n            }\n        }\n\n        if (cur > best)\n        {\n            best = cur;\n            ans = i - k + 1;\n        }\n    }\n\n    // Allocate memory for result string\n    char *result = (char *)malloc((k + 1) * sizeof(char));\n    if (best > 0)\n    {\n        strncpy(result, &s[ans], k);\n        result[k] = '\\0';\n    }\n    else\n    {\n        strcpy(result, \"Not found!\");\n    }\n\n    return result;\n}\n\nint main()\n{\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    char *s = malloc(200001 * sizeof(char));\n    scanf(\"%s\", s);\n\n    int k;\n    scanf(\"%d\", &k);\n\n    char *result = findSubstring(s, k);\n\n    fprintf(fptr, \"%s\\n\", result);\n\n    fclose(fptr);\n    free(s);\n    free(result);\n\n    return 0;\n}"
  }
]
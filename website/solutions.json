[
  {
    "name": "Active Traders.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CUSTOMERS 10000\n#define MAX_NAME_LEN 51\n\n// Structure for storing customer name and count\ntypedef struct {\n    char name[MAX_NAME_LEN];\n    int count;\n} Customer;\n\n// Comparator for qsort (alphabetical order)\nint compareNames(const void *a, const void *b) {\n    return strcmp(((Customer *)a)->name, ((Customer *)b)->name);\n}\n\n// Find or add customer to list\nint findOrAddCustomer(Customer customers[], int *size, const char *name) {\n    for (int i = 0; i < *size; ++i) {\n        if (strcmp(customers[i].name, name) == 0) {\n            customers[i].count++;\n            return i;\n        }\n    }\n    strcpy(customers[*size].name, name);\n    customers[*size].count = 1;\n    (*size)++;\n    return *size - 1;\n}\n\nint main() {\n    int customers_count;\n    scanf(\"%d\\n\", &customers_count);\n\n    Customer customers[MAX_CUSTOMERS];\n    int size = 0;\n\n    char name[MAX_NAME_LEN];\n\n    for (int i = 0; i < customers_count; ++i) {\n        fgets(name, MAX_NAME_LEN, stdin);\n        name[strcspn(name, \"\\n\")] = 0; // Remove newline\n        findOrAddCustomer(customers, &size, name);\n    }\n\n    // Calculate 5% threshold\n    double threshold = 0.05 * customers_count;\n\n    // Filter and collect active customers\n    Customer active[MAX_CUSTOMERS];\n    int active_count = 0;\n    for (int i = 0; i < size; ++i) {\n        if (customers[i].count >= threshold) {\n            active[active_count++] = customers[i];\n        }\n    }\n\n    // Sort the active customers alphabetically\n    qsort(active, active_count, sizeof(Customer), compareNames);\n\n    // Write output to OUTPUT_PATH file\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    for (int i = 0; i < active_count; ++i) {\n        fprintf(fptr, \"%s\\n\", active[i].name);\n    }\n    fclose(fptr);\n\n    return 0;\n}\n"
  },
  {
    "name": "Balanced System File Partition.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\ntypedef struct node {\n    int id;\n    int file_size;\n    struct node **children;\n    int children_count;\n    int children_capacity;\n    long long total_size;\n} Node;\n\nvoid add_child(Node *parent, Node *child) {\n    if (parent->children_count >= parent->children_capacity) {\n        parent->children_capacity = parent->children_capacity ? parent->children_capacity * 2 : 2;\n        parent->children = realloc(parent->children, parent->children_capacity * sizeof(Node *));\n    }\n    parent->children[parent->children_count++] = child;\n}\n\nlong long calculate_total_size(Node *node) {\n    node->total_size = node->file_size;\n    for (int i = 0; i < node->children_count; i++) {\n        node->total_size += calculate_total_size(node->children[i]);\n    }\n    return node->total_size;\n}\n\nint min_abs_diff(Node *root, long long total_size) {\n    int min_diff = INT_MAX;\n    \n    // Helper function to find minimum difference\n    void dfs(Node *node) {\n        if (node->id != 0) {  // Skip the root node\n            int diff = abs(total_size - 2 * node->total_size);\n            if (diff < min_diff) {\n                min_diff = diff;\n            }\n        }\n        \n        for (int i = 0; i < node->children_count; i++) {\n            dfs(node->children[i]);\n        }\n    }\n    \n    dfs(root);\n    return min_diff;\n}\n\nint mostBalancedPartition(int *parent, int parent_count, int *files_size, int files_size_count) {\n    // Create nodes\n    Node *nodes = malloc(parent_count * sizeof(Node));\n    for (int i = 0; i < parent_count; i++) {\n        nodes[i].id = i;\n        nodes[i].file_size = files_size[i];\n        nodes[i].children = NULL;\n        nodes[i].children_count = 0;\n        nodes[i].children_capacity = 0;\n        nodes[i].total_size = 0;\n    }\n    \n    // Build the tree\n    for (int i = 1; i < parent_count; i++) {\n        add_child(&nodes[parent[i]], &nodes[i]);\n    }\n    \n    // Calculate total sizes\n    long long total_size = calculate_total_size(&nodes[0]);\n    \n    // Find minimum difference\n    int result = min_abs_diff(&nodes[0], total_size);\n    \n    // Free allocated memory\n    for (int i = 0; i < parent_count; i++) {\n        free(nodes[i].children);\n    }\n    free(nodes);\n    \n    return result;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int parent_count;\n    scanf(\"%d\", &parent_count);\n    \n    int *parent = malloc(parent_count * sizeof(int));\n    for (int i = 0; i < parent_count; i++) {\n        scanf(\"%d\", &parent[i]);\n    }\n\n    int files_size_count;\n    scanf(\"%d\", &files_size_count);\n    \n    int *files_size = malloc(files_size_count * sizeof(int));\n    for (int i = 0; i < files_size_count; i++) {\n        scanf(\"%d\", &files_size[i]);\n    }\n\n    int result = mostBalancedPartition(parent, parent_count, files_size, files_size_count);\n    fprintf(fptr, \"%d\\n\", result);\n\n    free(parent);\n    free(files_size);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Longest Subarray.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint abs_diff(int a, int b) {\n    return a > b ? a - b : b - a;\n}\n\nint longestSubarray(int *arr, int arr_count) {\n    int ans = 0;\n    \n    // O(n^2) approach is fine given the constraints\n    for (int i = 0; i < arr_count; i++) {\n        int w[2] = {-1, -1}; // Store the two unique values\n        int w_count = 0;     // Count of unique values\n        int cnt = 0;         // Length of current subarray\n        \n        for (int j = i; j < arr_count; j++) {\n            // Check if current value is already in our window\n            int already_exists = 0;\n            for (int k = 0; k < w_count; k++) {\n                if (w[k] == arr[j]) {\n                    already_exists = 1;\n                    break;\n                }\n            }\n            \n            if (already_exists) {\n                cnt++;\n                continue;\n            }\n            \n            // If we have less than 2 unique values, add the current one\n            if (w_count == 0) {\n                w[w_count++] = arr[j];\n                cnt++;\n            } else if (w_count == 1) {\n                if (abs_diff(w[0], arr[j]) <= 1) {\n                    w[w_count++] = arr[j];\n                    cnt++;\n                } else {\n                    break;\n                }\n            } else {\n                // We already have 2 values and this is a new one, so break\n                break;\n            }\n        }\n        \n        ans = max(ans, cnt);\n    }\n    \n    return ans;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int arr_count;\n    scanf(\"%d\", &arr_count);\n    \n    int *arr = malloc(arr_count * sizeof(int));\n    for (int i = 0; i < arr_count; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int result = longestSubarray(arr, arr_count);\n    fprintf(fptr, \"%d\\n\", result);\n\n    free(arr);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Maximum Cost of Laptop Count.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint maxCost(int *cost, int cost_count, char **labels, int labels_count, int dailyCount) {\n    int ans = 0;\n    int cur_cnt = 0;\n    int cur_cost = 0;\n    \n    for (int i = 0; i < cost_count; i++) {\n        cur_cost += cost[i];\n        \n        if (strcmp(labels[i], \"illegal\") == 0) {\n            continue;\n        }\n        \n        cur_cnt++;\n        \n        if (cur_cnt == dailyCount) {\n            ans = max(ans, cur_cost);\n            cur_cnt = 0;\n            cur_cost = 0;\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int cost_count;\n    scanf(\"%d\", &cost_count);\n    \n    int *cost = malloc(cost_count * sizeof(int));\n    for (int i = 0; i < cost_count; i++) {\n        scanf(\"%d\", &cost[i]);\n    }\n\n    int labels_count;\n    scanf(\"%d\", &labels_count);\n    \n    char **labels = malloc(labels_count * sizeof(char*));\n    for (int i = 0; i < labels_count; i++) {\n        labels[i] = malloc(8 * sizeof(char)); // \"illegal\" or \"legal\" + null terminator\n        scanf(\"%s\", labels[i]);\n    }\n\n    int dailyCount;\n    scanf(\"%d\", &dailyCount);\n\n    int result = maxCost(cost, cost_count, labels, labels_count, dailyCount);\n    fprintf(fptr, \"%d\\n\", result);\n\n    for (int i = 0; i < labels_count; i++) {\n        free(labels[i]);\n    }\n    free(labels);\n    free(cost);\n    \n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Nearly Same Rectangles.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// GCD function\nlong gcd(long a, long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Structure to represent a reduced ratio\ntypedef struct {\n    long w;\n    long h;\n} Ratio;\n\n// Structure to store count of each ratio\ntypedef struct {\n    Ratio ratio;\n    int count;\n} RatioCount;\n\nlong nearlySimilarRectangles(long **sides, int sides_rows, int sides_columns) {\n    RatioCount *ratios = malloc(sides_rows * sizeof(RatioCount));\n    int unique_count = 0;\n    \n    // Process each rectangle\n    for (int i = 0; i < sides_rows; i++) {\n        long w = sides[i][0];\n        long h = sides[i][1];\n        long common_factor = gcd(w, h);\n        \n        // Reduce the ratio\n        Ratio current_ratio = {w / common_factor, h / common_factor};\n        \n        // Check if this ratio already exists\n        int found = 0;\n        for (int j = 0; j < unique_count; j++) {\n            if (ratios[j].ratio.w == current_ratio.w && ratios[j].ratio.h == current_ratio.h) {\n                ratios[j].count++;\n                found = 1;\n                break;\n            }\n        }\n        \n        // If not found, add new ratio\n        if (!found) {\n            ratios[unique_count].ratio = current_ratio;\n            ratios[unique_count].count = 1;\n            unique_count++;\n        }\n    }\n    \n    // Calculate the number of pairs\n    long result = 0;\n    for (int i = 0; i < unique_count; i++) {\n        long c = ratios[i].count;\n        result += (c * (c - 1)) / 2;\n    }\n    \n    free(ratios);\n    return result;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int sides_rows, sides_columns;\n    scanf(\"%d %d\", &sides_rows, &sides_columns);\n    \n    long **sides = malloc(sides_rows * sizeof(long*));\n    for (int i = 0; i < sides_rows; i++) {\n        sides[i] = malloc(sides_columns * sizeof(long));\n        for (int j = 0; j < sides_columns; j++) {\n            scanf(\"%ld\", &sides[i][j]);\n        }\n    }\n\n    long result = nearlySimilarRectangles(sides, sides_rows, sides_columns);\n    fprintf(fptr, \"%ld\\n\", result);\n\n    for (int i = 0; i < sides_rows; i++) {\n        free(sides[i]);\n    }\n    free(sides);\n    \n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Parallel Processing.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Comparison function for sorting in descending order\nint compare_desc(const void *a, const void *b) {\n    return *(int*)b - *(int*)a;\n}\n\nlong minTime(int *files, int files_count, int numCores, int limit) {\n    int *divisible = malloc(files_count * sizeof(int));\n    int *non_divisible = malloc(files_count * sizeof(int));\n    int div_count = 0, non_div_count = 0;\n    \n    // Separate files into divisible and non-divisible by numCores\n    for (int i = 0; i < files_count; i++) {\n        if (files[i] % numCores == 0) {\n            divisible[div_count++] = files[i];\n        } else {\n            non_divisible[non_div_count++] = files[i];\n        }\n    }\n    \n    // Sort divisible files in descending order\n    qsort(divisible, div_count, sizeof(int), compare_desc);\n    \n    // Calculate the total time\n    long total_time = 0;\n    \n    // Process divisible files up to the limit with parallel cores\n    for (int i = 0; i < div_count; i++) {\n        if (i < limit) {\n            total_time += divisible[i] / numCores;\n        } else {\n            total_time += divisible[i]; // Process sequentially\n        }\n    }\n    \n    // Add the time for non-divisible files\n    for (int i = 0; i < non_div_count; i++) {\n        total_time += non_divisible[i];\n    }\n    \n    free(divisible);\n    free(non_divisible);\n    \n    return total_time;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int files_count;\n    scanf(\"%d\", &files_count);\n    \n    int *files = malloc(files_count * sizeof(int));\n    for (int i = 0; i < files_count; i++) {\n        scanf(\"%d\", &files[i]);\n    }\n\n    int numCores, limit;\n    scanf(\"%d %d\", &numCores, &limit);\n\n    long result = minTime(files, files_count, numCores, limit);\n    fprintf(fptr, \"%ld\\n\", result);\n\n    free(files);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Password Decryption.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* decryptPassword(char* s) {\n    int len = strlen(s);\n    char* result = malloc((len + 1) * sizeof(char));\n    strcpy(result, s);\n    \n    // Find the position where digits end\n    int i = 0;\n    while (i < len && result[i] >= '1' && result[i] <= '9') {\n        i++;\n    }\n    \n    // Replace zeros with digits from the beginning\n    int zero_count = 0;\n    for (int j = i; j < len; j++) {\n        if (result[j] == '0') {\n            result[j] = result[i - zero_count - 1];\n            zero_count++;\n        }\n    }\n    \n    // Swap letters around '*'\n    for (int j = i; j < len; j++) {\n        if (result[j] == '*') {\n            char temp = result[j-1];\n            result[j-1] = result[j-2];\n            result[j-2] = temp;\n        }\n    }\n    \n    // Remove digits at the beginning and '*' characters\n    char* final_result = malloc((len + 1) * sizeof(char));\n    int k = 0;\n    for (int j = i; j < len; j++) {\n        if (result[j] != '*') {\n            final_result[k++] = result[j];\n        }\n    }\n    final_result[k] = '\\0';\n    \n    free(result);\n    return final_result;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    char s[100001];\n    scanf(\"%s\", s);\n\n    char* result = decryptPassword(s);\n    fprintf(fptr, \"%s\\n\", result);\n\n    free(result);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Road Repair.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nlong getMinCost(int *crew_id, int crew_id_count, int *job_id, int job_id_count) {\n    // Sort both arrays\n    qsort(crew_id, crew_id_count, sizeof(int), compare);\n    qsort(job_id, job_id_count, sizeof(int), compare);\n    \n    // Calculate minimum cost\n    long total_cost = 0;\n    for (int i = 0; i < crew_id_count; i++) {\n        int diff = crew_id[i] - job_id[i];\n        // Calculate absolute value\n        if (diff < 0) {\n            diff = -diff;\n        }\n        total_cost += diff;\n    }\n    \n    return total_cost;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int crew_id_count;\n    scanf(\"%d\", &crew_id_count);\n    \n    int *crew_id = malloc(crew_id_count * sizeof(int));\n    for (int i = 0; i < crew_id_count; i++) {\n        scanf(\"%d\", &crew_id[i]);\n    }\n\n    int job_id_count;\n    scanf(\"%d\", &job_id_count);\n    \n    int *job_id = malloc(job_id_count * sizeof(int));\n    for (int i = 0; i < job_id_count; i++) {\n        scanf(\"%d\", &job_id[i]);\n    }\n\n    long result = getMinCost(crew_id, crew_id_count, job_id, job_id_count);\n    fprintf(fptr, \"%ld\\n\", result);\n\n    free(crew_id);\n    free(job_id);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "String Anagram.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to compare characters for qsort\nint compare_chars(const void *a, const void *b) {\n    return (*(char*)a - *(char*)b);\n}\n\n// Structure to hold sorted words and their counts\ntypedef struct {\n    char *sorted_word;\n    int count;\n} WordCount;\n\nint* stringAnagram(char** dictionary, int dictionary_count, char** query, int query_count, int* result_count) {\n    // Allocate memory for the result\n    int *result = malloc(query_count * sizeof(int));\n    *result_count = query_count;\n    \n    // Create an array to store sorted words and their counts\n    WordCount *word_counts = malloc(dictionary_count * sizeof(WordCount));\n    int unique_count = 0;\n    \n    // Process dictionary words\n    for (int i = 0; i < dictionary_count; i++) {\n        int len = strlen(dictionary[i]);\n        char *sorted = malloc((len + 1) * sizeof(char));\n        strcpy(sorted, dictionary[i]);\n        \n        // Sort the word\n        qsort(sorted, len, sizeof(char), compare_chars);\n        \n        // Check if this sorted word already exists\n        int found = 0;\n        for (int j = 0; j < unique_count; j++) {\n            if (strcmp(sorted, word_counts[j].sorted_word) == 0) {\n                word_counts[j].count++;\n                found = 1;\n                free(sorted);\n                break;\n            }\n        }\n        \n        // If not found, add to the array\n        if (!found) {\n            word_counts[unique_count].sorted_word = sorted;\n            word_counts[unique_count].count = 1;\n            unique_count++;\n        }\n    }\n    \n    // Process queries\n    for (int i = 0; i < query_count; i++) {\n        int len = strlen(query[i]);\n        char *sorted = malloc((len + 1) * sizeof(char));\n        strcpy(sorted, query[i]);\n        \n        // Sort the query\n        qsort(sorted, len, sizeof(char), compare_chars);\n        \n        // Find matching sorted word\n        result[i] = 0;\n        for (int j = 0; j < unique_count; j++) {\n            if (strcmp(sorted, word_counts[j].sorted_word) == 0) {\n                result[i] = word_counts[j].count;\n                break;\n            }\n        }\n        \n        free(sorted);\n    }\n    \n    // Free allocated memory\n    for (int i = 0; i < unique_count; i++) {\n        free(word_counts[i].sorted_word);\n    }\n    free(word_counts);\n    \n    return result;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int dictionary_count;\n    scanf(\"%d\", &dictionary_count);\n    \n    char **dictionary = malloc(dictionary_count * sizeof(char*));\n    for (int i = 0; i < dictionary_count; i++) {\n        dictionary[i] = malloc(101 * sizeof(char)); // Assuming max word length is 100 chars\n        scanf(\"%s\", dictionary[i]);\n    }\n\n    int query_count;\n    scanf(\"%d\", &query_count);\n    \n    char **query = malloc(query_count * sizeof(char*));\n    for (int i = 0; i < query_count; i++) {\n        query[i] = malloc(101 * sizeof(char));\n        scanf(\"%s\", query[i]);\n    }\n\n    int result_count;\n    int *result = stringAnagram(dictionary, dictionary_count, query, query_count, &result_count);\n\n    for (int i = 0; i < result_count; i++) {\n        fprintf(fptr, \"%d\\n\", result[i]);\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < dictionary_count; i++) {\n        free(dictionary[i]);\n    }\n    free(dictionary);\n    \n    for (int i = 0; i < query_count; i++) {\n        free(query[i]);\n    }\n    free(query);\n    \n    free(result);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Subarray Sums.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nlong* findSum(int* numbers, int numbers_count, int** queries, int queries_rows, int queries_columns, int* result_count) {\n    // Prefix sums for numbers and zero count\n    long *prefix_sum = malloc((numbers_count + 1) * sizeof(long));\n    int *zero_count = malloc((numbers_count + 1) * sizeof(int));\n    \n    prefix_sum[0] = 0;\n    zero_count[0] = 0;\n    \n    for (int i = 0; i < numbers_count; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + numbers[i];\n        zero_count[i + 1] = zero_count[i] + (numbers[i] == 0 ? 1 : 0);\n    }\n    \n    // Allocate memory for results\n    *result_count = queries_rows;\n    long *result = malloc(queries_rows * sizeof(long));\n    \n    // Process each query\n    for (int i = 0; i < queries_rows; i++) {\n        int l = queries[i][0];\n        int r = queries[i][1];\n        int x = queries[i][2];\n        \n        // Calculate sum of subarray and add x * (count of zeros)\n        result[i] = prefix_sum[r] - prefix_sum[l - 1] + x * (zero_count[r] - zero_count[l - 1]);\n    }\n    \n    free(prefix_sum);\n    free(zero_count);\n    \n    return result;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int numbers_count;\n    scanf(\"%d\", &numbers_count);\n    \n    int *numbers = malloc(numbers_count * sizeof(int));\n    for (int i = 0; i < numbers_count; i++) {\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    int queries_rows, queries_columns;\n    scanf(\"%d %d\", &queries_rows, &queries_columns);\n    \n    int **queries = malloc(queries_rows * sizeof(int*));\n    for (int i = 0; i < queries_rows; i++) {\n        queries[i] = malloc(queries_columns * sizeof(int));\n        for (int j = 0; j < queries_columns; j++) {\n            scanf(\"%d\", &queries[i][j]);\n        }\n    }\n\n    int result_count;\n    long *result = findSum(numbers, numbers_count, queries, queries_rows, queries_columns, &result_count);\n\n    for (int i = 0; i < result_count; i++) {\n        fprintf(fptr, \"%ld\\n\", result[i]);\n    }\n\n    // Free allocated memory\n    free(numbers);\n    for (int i = 0; i < queries_rows; i++) {\n        free(queries[i]);\n    }\n    free(queries);\n    free(result);\n    \n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Unexpected Demands.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint filledOrders(int* order, int order_count, int k) {\n    // Sort the orders\n    qsort(order, order_count, sizeof(int), compare);\n    \n    int fulfilled = 0;\n    \n    // Process orders in ascending order\n    for (int i = 0; i < order_count; i++) {\n        if (order[i] <= k) {\n            fulfilled++;\n            k -= order[i];\n        } else {\n            break;\n        }\n    }\n    \n    return fulfilled;\n}\n\nint main() {\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n\n    int order_count;\n    scanf(\"%d\", &order_count);\n    \n    int *order = malloc(order_count * sizeof(int));\n    for (int i = 0; i < order_count; i++) {\n        scanf(\"%d\", &order[i]);\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int result = filledOrders(order, order_count, k);\n    fprintf(fptr, \"%d\\n\", result);\n\n    free(order);\n    fclose(fptr);\n    return 0;\n}"
  },
  {
    "name": "Username Changes.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_USERNAME_LEN 1001\n#define MAX_USERNAMES 1000\n\n// Function to check if a username can be changed to a lexicographically smaller version\nconst char* canBeChanged(const char* username) {\n    int len = strlen(username);\n    for (int i = 0; i < len - 1; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (username[i] > username[j]) {\n                return \"YES\";\n            }\n        }\n    }\n    return \"NO\";\n}\n\nint main() {\n    int usernames_count;\n    scanf(\"%d\\n\", &usernames_count);\n\n    char usernames[MAX_USERNAMES][MAX_USERNAME_LEN];\n    char results[MAX_USERNAMES][4]; // \"YES\" or \"NO\"\n\n    // Read usernames\n    for (int i = 0; i < usernames_count; i++) {\n        fgets(usernames[i], MAX_USERNAME_LEN, stdin);\n        usernames[i][strcspn(usernames[i], \"\\n\")] = 0; // Remove newline\n    }\n\n    // Process each username\n    for (int i = 0; i < usernames_count; i++) {\n        strcpy(results[i], canBeChanged(usernames[i]));\n    }\n\n    // Write output to OUTPUT_PATH\n    FILE *fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    if (!fptr) {\n        fprintf(stderr, \"Error opening OUTPUT_PATH\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i < usernames_count; i++) {\n        fprintf(fptr, \"%s\\n\", results[i]);\n    }\n\n    fclose(fptr);\n    return 0;\n}\n"
  },
  {
    "name": "Vowel Substring.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LEN 100001\n\n// Function to check if a character is a vowel\nint isVowel(char c) {\n    c = tolower(c);\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\n// Function to find substring with the maximum number of vowels\nchar* findSubstring(const char* s, int k) {\n    int len = strlen(s);\n    int cur = 0, best = 0, start = -1;\n\n    // Count vowels in the first window\n    for (int i = 0; i < k && i < len; i++) {\n        cur += isVowel(s[i]);\n    }\n\n    best = cur;\n    if (best > 0) start = 0;\n\n    // Slide the window\n    for (int i = k; i < len; i++) {\n        cur += isVowel(s[i]);\n        cur -= isVowel(s[i - k]);\n        if (cur > best) {\n            best = cur;\n            start = i - k + 1;\n        }\n    }\n\n    // Return result\n    char* result = (char*)malloc((k + 20) * sizeof(char));\n    if (best > 0 && start != -1) {\n        strncpy(result, s + start, k);\n        result[k] = '\\0';\n    } else {\n        strcpy(result, \"Not found!\");\n    }\n    return result;\n}\n\nint main() {\n    char s[MAX_LEN];\n    int k;\n\n    fgets(s, MAX_LEN, stdin);\n    s[strcspn(s, \"\\n\")] = '\\0'; // Remove newline\n\n    scanf(\"%d\", &k);\n\n    char* result = findSubstring(s, k);\n\n    FILE* fptr = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    if (!fptr) {\n        fprintf(stderr, \"Error opening OUTPUT_PATH\\n\");\n        return 1;\n    }\n\n    fprintf(fptr, \"%s\\n\", result);\n    fclose(fptr);\n\n    free(result);\n    return 0;\n}\n"
  }
]